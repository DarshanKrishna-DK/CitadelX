# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "Name of the DAO", "name": "dao_name"}, {"type": "string", "desc": "DAO description", "name": "description"}, {"type": "string", "desc": "AI moderator category", "name": "category"}, {"type": "uint64", "desc": "Minimum members required", "name": "min_members"}, {"type": "uint64", "desc": "Minimum stake per member in microAlgos", "name": "min_stake"}, {"type": "uint64", "desc": "Voting period in seconds", "name": "voting_period"}, {"type": "uint64", "desc": "Percentage needed to pass (51-100)", "name": "activation_threshold"}, {"type": "pay", "desc": "Initial treasury contribution payment", "name": "payment_txn"}], "name": "create_dao_proposal", "returns": {"type": "string", "desc": "DAO ID"}, "desc": "Create a DAO proposal with initial treasury contribution", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "ID of the DAO to join", "name": "dao_id"}, {"type": "pay", "desc": "Stake payment transaction", "name": "payment_txn"}], "name": "join_dao", "returns": {"type": "string", "desc": "Success message"}, "desc": "Join an existing DAO with required stake payment", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "ID of the DAO", "name": "dao_id"}, {"type": "string", "desc": "Title of the proposal", "name": "proposal_title"}, {"type": "string", "desc": "Description with context documents", "name": "proposal_description"}, {"type": "string", "desc": "Category of AI moderator", "name": "moderator_category"}], "name": "create_proposal", "returns": {"type": "string", "desc": "Proposal ID"}, "desc": "Create a new proposal for DAO activation and AI moderator creation", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "ID of the proposal", "name": "proposal_id"}, {"type": "bool", "desc": "True for yes, False for no", "name": "vote_yes"}], "name": "vote_on_proposal", "returns": {"type": "string", "desc": "Success message with updated vote count"}, "desc": "Cast a vote on a proposal (members can only vote once)", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "ID of the passed proposal", "name": "proposal_id"}, {"type": "string", "desc": "Name for the AI moderator", "name": "moderator_name"}], "name": "execute_proposal", "returns": {"type": "uint64", "desc": "NFT Asset ID (mock for now)"}, "desc": "Execute a passed proposal and mint NFT for AI moderator", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "ID of the DAO", "name": "dao_id"}, {"type": "uint64", "desc": "Revenue to distribute in microAlgos", "name": "revenue_amount"}], "name": "distribute_revenue", "returns": {"type": "string", "desc": "Success message"}, "desc": "Distribute revenue among DAO members proportionally", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "ID of the DAO", "name": "dao_id"}], "name": "get_dao_info", "returns": {"type": "string", "desc": "DAO information as formatted string"}, "desc": "Get DAO configuration and status", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "ID of the proposal", "name": "proposal_id"}], "name": "get_proposal_info", "returns": {"type": "string", "desc": "Proposal information as formatted string"}, "desc": "Get proposal details and voting status", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "ID of the DAO", "name": "dao_id"}, {"type": "account", "desc": "Address to check", "name": "member_address"}], "name": "check_membership", "returns": {"type": "bool", "desc": "True if member, False otherwise"}, "desc": "Check if an address is a member of a DAO", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "ID of the DAO", "name": "dao_id"}], "name": "get_treasury_balance", "returns": {"type": "uint64", "desc": "Treasury balance in microAlgos"}, "desc": "Get DAO treasury balance", "events": [], "readonly": true, "recommendations": {}}], "name": "CitadelDAO", "state": {"keys": {"box": {}, "global": {"dao_counter": {"key": "ZGFvX2NvdW50ZXI=", "keyType": "AVMString", "valueType": "AVMUint64"}, "proposal_counter": {"key": "cHJvcG9zYWxfY291bnRlcg==", "keyType": "AVMString", "valueType": "AVMUint64"}}, "local": {}}, "maps": {"box": {"dao_configs": {"keyType": "AVMBytes", "valueType": "DAOConfig", "prefix": "ZGFvX2NvbmZpZ18="}, "proposals": {"keyType": "AVMBytes", "valueType": "ProposalData", "prefix": "cHJvcG9zYWxf"}, "member_stakes": {"keyType": "AVMBytes", "valueType": "uint64", "prefix": "c3Rha2Vf"}, "votes": {"keyType": "AVMBytes", "valueType": "uint64", "prefix": "dm90ZV8="}, "treasury_balances": {"keyType": "AVMBytes", "valueType": "uint64", "prefix": "dHJlYXN1cnlf"}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 2}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"DAOConfig": [{"name": "min_members", "type": "uint64"}, {"name": "min_stake", "type": "uint64"}, {"name": "voting_period", "type": "uint64"}, {"name": "activation_threshold", "type": "uint64"}, {"name": "creator", "type": "address"}], "ProposalData": [{"name": "dao_id", "type": "string"}, {"name": "title", "type": "string"}, {"name": "description", "type": "string"}, {"name": "creator", "type": "address"}, {"name": "required_votes", "type": "uint64"}, {"name": "current_votes", "type": "uint64"}, {"name": "status", "type": "string"}, {"name": "created_at", "type": "uint64"}]}, "byteCode": {"approval": "CiAEAQACNiYJBBUffHUGc3Rha2VfC2Rhb19jb25maWdfCXRyZWFzdXJ5Xwlwcm9wb3NhbF8LZGFvX2NvdW50ZXIQcHJvcG9zYWxfY291bnRlcgZhY3RpdmUGcGFzc2VkMRhAAAgnBSNnJwYjZzEbQQG6ggoEOvvtqAShm/04BHYwVqgEJp+F5ARZhzgcBOPBPzUEXfqrBQRVnWHGBK1gptIEwg55KjYaAI4KASkBAQDRALAAkwBxAFMANQAZAAIjQzEZFEQxGEQ2GgFXAgCIBdAWKExQsCJDMRkURDEYRDYaAVcCADYaAhfAHIgFnShMULAiQzEZFEQxGEQ2GgFXAgCIBQpJFRZXBgJMUChMULAiQzEZFEQxGEQ2GgFXAgCIBHVJFRZXBgJMUChMULAiQzEZFEQxGEQ2GgFXAgA2GgIXiAQSSRUWVwYCTFAoTFCwIkMxGRREMRhENhoBVwIANhoCVwIAiAM+FihMULAiQzEZFEQxGEQ2GgFXAgA2GgKIAkpJFRZXBgJMUChMULAiQzEZFEQxGEQ2GgFXAgA2GgJXAgA2GgNXAgA2GgRXAgCIAX9JFRZXBgJMUChMULAiQzEZFEQxGEQ2GgFXAgAxFiIJSTgQIhJEiADvSRUWVwYCTFAoTFCwIkMxGRREMRhENhoBVwIANhoCVwIANhoDVwIANhoEFzYaBRc2GgYXNhoHFzEWIglJOBAiEkSIABlJFRZXBgJMUChMULAiQzEZQP6OMRgURCJDiggBi/skD0SL/IGgjQYPRIv+gTMPQQB2i/6BZA5BAG4iRIv9gYCjBQ9Ei/84BzIKEkSL/zgAMQASRIv/OAhJi/wPRCMnBWVEIggnBUsBZxaABGRhb19MUIv7Fov8Fov9Fov+FjEATwRPBFBPA1BPAlBMUCpLAlBMv0kxAFApTFBPAhZMSwG/K0sCUEy/iSNC/4+KAgEqi/5QSb1FAUS+RIv/OAcyChJEi/84ADEAEkSL/zgITIEIW0sBDkSL/jEAUClMUEm+RQEUREsBFr8ri/5QSb5EF08CCBa/gBlTdWNjZXNzZnVsbHkgam9pbmVkIERBTzogi/5QiYoEASqL/FBJvUUBRL5Ei/wxAFApTFC+RQFEIycGZUQiCCcGSwFnFoAFcHJvcF9MUEsBI1tPAoEYWwuBZAoxAEwWMgcWi/wVgUAISRZXBgKAAgBATFCL/RVPAghJFlcGAk8CTFCL/hVPAghMTwRQTwNQgAgAAAAAAAAAAFBMFlcGAlBMUIv8UIv9UIv+UCcHUCcESwJQSbxITL+JigIBJwSL/lBHAr1FAUS+TElPAkRJJVlLARVLAk4CUicHEkRJI1lLASRZSwJOAlIxAFApTFC+RQFEi/4xAFCABXZvdGVfTFBJvkUBFESL/4ABABNJTgMkIksCTRZPAky/QQAriwFJgS5bIggWXC5JjAFJgS5bSwGBJlsPTIwDQQANiwFJJVkjTFgnCFCMA4sDSYwBiwBJvEhMv4sCQQA0gAN5ZXOAC1ZvdGUgY2FzdDogTFCAEywgVG90YWwgeWVzIHZvdGVzOiBQiwGBLlsWUIwAiYACbm9C/8qKAgEnBIv+UEm9RQFESb5ESSVZSwEVSwJLAk8CUicIEkRLASNZSwIkWUsDTgJSMQBQKUxQvkUBREsBgQRZSwJMSwJSsQEyCkcDsiyyK7IqsimyKIAeaHR0cHM6Ly9jaXRhZGVseC5haS9tb2RlcmF0b3IvsieABkNJVE1PRLIli/+yJiOyJCOyIyKyIoEDshAjsgGzMgdPAiNPA1iACGV4ZWN1dGVkUEsCvEhPAky/iYoCASqL/lC9RQFEK4v+UEm+RBeL/wgWv4AjUmV2ZW51ZSBhZGRlZCB0byB0cmVhc3VyeSBmb3IgREFPOiCL/lCJigEBKov/UEm9RQFAABGADURBTyBub3QgZm91bmRMiYsAvkQri/9QvkQXgAVEQU86IIv/UIAPLCBNaW4gTWVtYmVyczogUEsCI1sWUIANLCBNaW4gU3Rha2U6IFBPAoEIWxZQgAwsIFRyZWFzdXJ5OiBQTBZQTImKAQEnBIv/UEm9RQFAABaAElByb3Bvc2FsIG5vdCBmb3VuZEyJiwC+REkkWUsBgQRZSwJOAlKAClByb3Bvc2FsOiBMUIAKLCBTdGF0dXM6IFBLASVZSwIVSwNOAlJQgAksIFZvdGVzOiBQSwGBLlsWUIABL1BMgSZbFlBMiYoCAYv+i/9QKUxQvkUBgAEAI08CVImKAQEri/9QvkQXiQ==", "clear": "CoEBQw=="}, "desc": "\n    Enhanced CitadelDAO Smart Contract\n    \n    Manages DAO creation, membership, proposals, voting with proper payment handling,\n    and revenue distribution with comprehensive state management\n    ", "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMuY2l0YWRlbF9kYW8uY29udHJhY3QuQ2l0YWRlbERBTy5fX2FsZ29weV9lbnRyeXBvaW50X3dpdGhfaW5pdCgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAxIDAgMiA1NAogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1IDB4NzM3NDYxNmI2NTVmIDB4NjQ2MTZmNWY2MzZmNmU2NjY5Njc1ZiAweDc0NzI2NTYxNzM3NTcyNzk1ZiAweDcwNzI2ZjcwNmY3MzYxNmM1ZiAiZGFvX2NvdW50ZXIiICJwcm9wb3NhbF9jb3VudGVyIiAweDYxNjM3NDY5NzY2NSAweDcwNjE3MzczNjU2NAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjUwLTUxCiAgICAvLyAjIEdsb2JhbCBjb3VudGVyIGZvciB1bmlxdWUgSURzCiAgICAvLyBzZWxmLmRhb19jb3VudGVyID0gR2xvYmFsU3RhdGUoVUludDY0KDApLCBrZXk9ImRhb19jb3VudGVyIikKICAgIGJ5dGVjIDUgLy8gImRhb19jb3VudGVyIgogICAgaW50Y18xIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6NTIKICAgIC8vIHNlbGYucHJvcG9zYWxfY291bnRlciA9IEdsb2JhbFN0YXRlKFVJbnQ2NCgwKSwga2V5PSJwcm9wb3NhbF9jb3VudGVyIikKICAgIGJ5dGVjIDYgLy8gInByb3Bvc2FsX2NvdW50ZXIiCiAgICBpbnRjXzEgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKCm1haW5fYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI2CiAgICAvLyBjbGFzcyBDaXRhZGVsREFPKEFSQzRDb250cmFjdCk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9iYXJlX3JvdXRpbmdAMTUKICAgIHB1c2hieXRlc3MgMHgzYWZiZWRhOCAweGExOWJmZDM4IDB4NzYzMDU2YTggMHgyNjlmODVlNCAweDU5ODczODFjIDB4ZTNjMTNmMzUgMHg1ZGZhYWIwNSAweDU1OWQ2MWM2IDB4YWQ2MGE2ZDIgMHhjMjBlNzkyYSAvLyBtZXRob2QgImNyZWF0ZV9kYW9fcHJvcG9zYWwoc3RyaW5nLHN0cmluZyxzdHJpbmcsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHBheSlzdHJpbmciLCBtZXRob2QgImpvaW5fZGFvKHN0cmluZyxwYXkpc3RyaW5nIiwgbWV0aG9kICJjcmVhdGVfcHJvcG9zYWwoc3RyaW5nLHN0cmluZyxzdHJpbmcsc3RyaW5nKXN0cmluZyIsIG1ldGhvZCAidm90ZV9vbl9wcm9wb3NhbChzdHJpbmcsYm9vbClzdHJpbmciLCBtZXRob2QgImV4ZWN1dGVfcHJvcG9zYWwoc3RyaW5nLHN0cmluZyl1aW50NjQiLCBtZXRob2QgImRpc3RyaWJ1dGVfcmV2ZW51ZShzdHJpbmcsdWludDY0KXN0cmluZyIsIG1ldGhvZCAiZ2V0X2Rhb19pbmZvKHN0cmluZylzdHJpbmciLCBtZXRob2QgImdldF9wcm9wb3NhbF9pbmZvKHN0cmluZylzdHJpbmciLCBtZXRob2QgImNoZWNrX21lbWJlcnNoaXAoc3RyaW5nLGFjY291bnQpYm9vbCIsIG1ldGhvZCAiZ2V0X3RyZWFzdXJ5X2JhbGFuY2Uoc3RyaW5nKXVpbnQ2NCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fY3JlYXRlX2Rhb19wcm9wb3NhbF9yb3V0ZUA1IG1haW5fam9pbl9kYW9fcm91dGVANiBtYWluX2NyZWF0ZV9wcm9wb3NhbF9yb3V0ZUA3IG1haW5fdm90ZV9vbl9wcm9wb3NhbF9yb3V0ZUA4IG1haW5fZXhlY3V0ZV9wcm9wb3NhbF9yb3V0ZUA5IG1haW5fZGlzdHJpYnV0ZV9yZXZlbnVlX3JvdXRlQDEwIG1haW5fZ2V0X2Rhb19pbmZvX3JvdXRlQDExIG1haW5fZ2V0X3Byb3Bvc2FsX2luZm9fcm91dGVAMTIgbWFpbl9jaGVja19tZW1iZXJzaGlwX3JvdXRlQDEzIG1haW5fZ2V0X3RyZWFzdXJ5X2JhbGFuY2Vfcm91dGVAMTQKCm1haW5fYWZ0ZXJfaWZfZWxzZUAxNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyNgogICAgLy8gY2xhc3MgQ2l0YWRlbERBTyhBUkM0Q29udHJhY3QpOgogICAgaW50Y18xIC8vIDAKICAgIHJldHVybgoKbWFpbl9nZXRfdHJlYXN1cnlfYmFsYW5jZV9yb3V0ZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozOTkKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI2CiAgICAvLyBjbGFzcyBDaXRhZGVsREFPKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM5OQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBnZXRfdHJlYXN1cnlfYmFsYW5jZQogICAgaXRvYgogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKbWFpbl9jaGVja19tZW1iZXJzaGlwX3JvdXRlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM4MgogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjYKICAgIC8vIGNsYXNzIENpdGFkZWxEQU8oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG5hcyBBY2NvdW50cwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM4MgogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBjaGVja19tZW1iZXJzaGlwCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF9wcm9wb3NhbF9pbmZvX3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM1OQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjYKICAgIC8vIGNsYXNzIENpdGFkZWxEQU8oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzU5CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBjYWxsc3ViIGdldF9wcm9wb3NhbF9pbmZvCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRfZGFvX2luZm9fcm91dGVAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzM1CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyNgogICAgLy8gY2xhc3MgQ2l0YWRlbERBTyhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozMzUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGNhbGxzdWIgZ2V0X2Rhb19pbmZvCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKbWFpbl9kaXN0cmlidXRlX3JldmVudWVfcm91dGVAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzA1CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI2CiAgICAvLyBjbGFzcyBDaXRhZGVsREFPKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjMwNQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGRpc3RyaWJ1dGVfcmV2ZW51ZQogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCm1haW5fZXhlY3V0ZV9wcm9wb3NhbF9yb3V0ZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI2MwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyNgogICAgLy8gY2xhc3MgQ2l0YWRlbERBTyhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjYzCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgZXhlY3V0ZV9wcm9wb3NhbAogICAgaXRvYgogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKbWFpbl92b3RlX29uX3Byb3Bvc2FsX3JvdXRlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjExCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI2CiAgICAvLyBjbGFzcyBDaXRhZGVsREFPKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjIxMQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIHZvdGVfb25fcHJvcG9zYWwKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9wcm9wb3NhbF9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjE1NwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyNgogICAgLy8gY2xhc3MgQ2l0YWRlbERBTyhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToxNTcKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiBjcmVhdGVfcHJvcG9zYWwKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2pvaW5fZGFvX3JvdXRlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTE2CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI2CiAgICAvLyBjbGFzcyBDaXRhZGVsREFPKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMCAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTE2CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgam9pbl9kYW8KICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9kYW9fcHJvcG9zYWxfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo1NAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyNgogICAgLy8gY2xhc3MgQ2l0YWRlbERBTyhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwogICAgYnRvaQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMCAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6NTQKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiBjcmVhdGVfZGFvX3Byb3Bvc2FsCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKbWFpbl9iYXJlX3JvdXRpbmdAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjYKICAgIC8vIGNsYXNzIENpdGFkZWxEQU8oQVJDNENvbnRyYWN0KToKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMTcKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNpdGFkZWxfZGFvLmNvbnRyYWN0LkNpdGFkZWxEQU8uY3JlYXRlX2Rhb19wcm9wb3NhbChkYW9fbmFtZTogYnl0ZXMsIGRlc2NyaXB0aW9uOiBieXRlcywgY2F0ZWdvcnk6IGJ5dGVzLCBtaW5fbWVtYmVyczogdWludDY0LCBtaW5fc3Rha2U6IHVpbnQ2NCwgdm90aW5nX3BlcmlvZDogdWludDY0LCBhY3RpdmF0aW9uX3RocmVzaG9sZDogdWludDY0LCBwYXltZW50X3R4bjogdWludDY0KSAtPiBieXRlczoKY3JlYXRlX2Rhb19wcm9wb3NhbDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo1NC02NQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY3JlYXRlX2Rhb19wcm9wb3NhbCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRhb19uYW1lOiBTdHJpbmcsCiAgICAvLyAgICAgZGVzY3JpcHRpb246IFN0cmluZywKICAgIC8vICAgICBjYXRlZ29yeTogU3RyaW5nLAogICAgLy8gICAgIG1pbl9tZW1iZXJzOiBVSW50NjQsCiAgICAvLyAgICAgbWluX3N0YWtlOiBVSW50NjQsCiAgICAvLyAgICAgdm90aW5nX3BlcmlvZDogVUludDY0LAogICAgLy8gICAgIGFjdGl2YXRpb25fdGhyZXNob2xkOiBVSW50NjQsCiAgICAvLyAgICAgcGF5bWVudF90eG46IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBTdHJpbmc6CiAgICBwcm90byA4IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo4Mi04MwogICAgLy8gIyBWYWxpZGF0ZSBpbnB1dHMKICAgIC8vIGFzc2VydCBtaW5fbWVtYmVycyA+PSAyLCAiTWluaW11bSAyIG1lbWJlcnMgcmVxdWlyZWQgZm9yIERBTyIKICAgIGZyYW1lX2RpZyAtNQogICAgaW50Y18yIC8vIDIKICAgID49CiAgICBhc3NlcnQgLy8gTWluaW11bSAyIG1lbWJlcnMgcmVxdWlyZWQgZm9yIERBTwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5Ojg0CiAgICAvLyBhc3NlcnQgbWluX3N0YWtlID49IDEwMDAwMCwgIk1pbmltdW0gc3Rha2UgbXVzdCBiZSBhdCBsZWFzdCAwLjEgQUxHTyIgICMgMC4xIEFMR08KICAgIGZyYW1lX2RpZyAtNAogICAgcHVzaGludCAxMDAwMDAgLy8gMTAwMDAwCiAgICA+PQogICAgYXNzZXJ0IC8vIE1pbmltdW0gc3Rha2UgbXVzdCBiZSBhdCBsZWFzdCAwLjEgQUxHTwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5Ojg1CiAgICAvLyBhc3NlcnQgYWN0aXZhdGlvbl90aHJlc2hvbGQgPj0gNTEgYW5kIGFjdGl2YXRpb25fdGhyZXNob2xkIDw9IDEwMCwgIlRocmVzaG9sZCBtdXN0IGJlIGJldHdlZW4gNTEtMTAwIgogICAgZnJhbWVfZGlnIC0yCiAgICBwdXNoaW50IDUxIC8vIDUxCiAgICA+PQogICAgYnogY3JlYXRlX2Rhb19wcm9wb3NhbF9ib29sX2ZhbHNlQDMKICAgIGZyYW1lX2RpZyAtMgogICAgcHVzaGludCAxMDAgLy8gMTAwCiAgICA8PQogICAgYnogY3JlYXRlX2Rhb19wcm9wb3NhbF9ib29sX2ZhbHNlQDMKICAgIGludGNfMCAvLyAxCgpjcmVhdGVfZGFvX3Byb3Bvc2FsX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo4NQogICAgLy8gYXNzZXJ0IGFjdGl2YXRpb25fdGhyZXNob2xkID49IDUxIGFuZCBhY3RpdmF0aW9uX3RocmVzaG9sZCA8PSAxMDAsICJUaHJlc2hvbGQgbXVzdCBiZSBiZXR3ZWVuIDUxLTEwMCIKICAgIGFzc2VydCAvLyBUaHJlc2hvbGQgbXVzdCBiZSBiZXR3ZWVuIDUxLTEwMAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5Ojg2CiAgICAvLyBhc3NlcnQgdm90aW5nX3BlcmlvZCA+PSA4NjQwMCwgIlZvdGluZyBwZXJpb2QgbXVzdCBiZSBhdCBsZWFzdCAxIGRheSIgICMgMSBkYXkgaW4gc2Vjb25kcwogICAgZnJhbWVfZGlnIC0zCiAgICBwdXNoaW50IDg2NDAwIC8vIDg2NDAwCiAgICA+PQogICAgYXNzZXJ0IC8vIFZvdGluZyBwZXJpb2QgbXVzdCBiZSBhdCBsZWFzdCAxIGRheQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5Ojg4LTg5CiAgICAvLyAjIFZlcmlmeSBwYXltZW50IHRyYW5zYWN0aW9uCiAgICAvLyBhc3NlcnQgcGF5bWVudF90eG4ucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywgIlBheW1lbnQgbXVzdCBiZSB0byBjb250cmFjdCIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFBheW1lbnQgbXVzdCBiZSB0byBjb250cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjkwCiAgICAvLyBhc3NlcnQgcGF5bWVudF90eG4uc2VuZGVyID09IFR4bi5zZW5kZXIsICJQYXltZW50IHNlbmRlciBtdXN0IG1hdGNoIHRyYW5zYWN0aW9uIHNlbmRlciIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgU2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICA9PQogICAgYXNzZXJ0IC8vIFBheW1lbnQgc2VuZGVyIG11c3QgbWF0Y2ggdHJhbnNhY3Rpb24gc2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6OTEKICAgIC8vIGFzc2VydCBwYXltZW50X3R4bi5hbW91bnQgPj0gbWluX3N0YWtlLCAiSW5pdGlhbCBwYXltZW50IG11c3QgbWVldCBtaW5pbXVtIHN0YWtlIgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGR1cAogICAgZnJhbWVfZGlnIC00CiAgICA+PQogICAgYXNzZXJ0IC8vIEluaXRpYWwgcGF5bWVudCBtdXN0IG1lZXQgbWluaW11bSBzdGFrZQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjkzLTk0CiAgICAvLyAjIEdlbmVyYXRlIHVuaXF1ZSBEQU8gSUQKICAgIC8vIHNlbGYuZGFvX2NvdW50ZXIudmFsdWUgKz0gVUludDY0KDEpCiAgICBpbnRjXzEgLy8gMAogICAgYnl0ZWMgNSAvLyAiZGFvX2NvdW50ZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGFvX2NvdW50ZXIgZXhpc3RzCiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgYnl0ZWMgNSAvLyAiZGFvX2NvdW50ZXIiCiAgICBkaWcgMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo5NQogICAgLy8gZGFvX2lkX2J5dGVzID0gb3AuY29uY2F0KEJ5dGVzKGIiZGFvXyIpLCBvcC5pdG9iKHNlbGYuZGFvX2NvdW50ZXIudmFsdWUpKQogICAgaXRvYgogICAgcHVzaGJ5dGVzIDB4NjQ2MTZmNWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBtaW5fbWVtYmVycz1BUkM0VUludDY0KG1pbl9tZW1iZXJzKSwKICAgIGZyYW1lX2RpZyAtNQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjEwMAogICAgLy8gbWluX3N0YWtlPUFSQzRVSW50NjQobWluX3N0YWtlKSwKICAgIGZyYW1lX2RpZyAtNAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjEwMQogICAgLy8gdm90aW5nX3BlcmlvZD1BUkM0VUludDY0KHZvdGluZ19wZXJpb2QpLAogICAgZnJhbWVfZGlnIC0zCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTAyCiAgICAvLyBhY3RpdmF0aW9uX3RocmVzaG9sZD1BUkM0VUludDY0KGFjdGl2YXRpb25fdGhyZXNob2xkKSwKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjEwMwogICAgLy8gY3JlYXRvcj1BZGRyZXNzKFR4bi5zZW5kZXIpCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6OTctMTA0CiAgICAvLyAjIFN0b3JlIERBTyBjb25maWd1cmF0aW9uCiAgICAvLyBkYW9fY29uZmlnID0gREFPQ29uZmlnKAogICAgLy8gICAgIG1pbl9tZW1iZXJzPUFSQzRVSW50NjQobWluX21lbWJlcnMpLAogICAgLy8gICAgIG1pbl9zdGFrZT1BUkM0VUludDY0KG1pbl9zdGFrZSksCiAgICAvLyAgICAgdm90aW5nX3BlcmlvZD1BUkM0VUludDY0KHZvdGluZ19wZXJpb2QpLAogICAgLy8gICAgIGFjdGl2YXRpb25fdGhyZXNob2xkPUFSQzRVSW50NjQoYWN0aXZhdGlvbl90aHJlc2hvbGQpLAogICAgLy8gICAgIGNyZWF0b3I9QWRkcmVzcyhUeG4uc2VuZGVyKQogICAgLy8gKQogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToxMDUKICAgIC8vIHNlbGYuZGFvX2NvbmZpZ3NbZGFvX2lkX2J5dGVzXSA9IGRhb19jb25maWcuY29weSgpCiAgICBieXRlY18yIC8vIDB4NjQ2MTZmNWY2MzZmNmU2NjY5Njc1ZgogICAgZGlnIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjEwNy0xMDgKICAgIC8vICMgUmVjb3JkIGNyZWF0b3IncyBzdGFrZQogICAgLy8gbWVtYmVyX2tleSA9IGRhb19pZF9ieXRlcyArIFR4bi5zZW5kZXIuYnl0ZXMKICAgIGR1cAogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTA5CiAgICAvLyBzZWxmLm1lbWJlcl9zdGFrZXNbbWVtYmVyX2tleV0gPSBwYXltZW50X3R4bi5hbW91bnQKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE2YjY1NWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICBzd2FwCiAgICBkaWcgMQogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjExMS0xMTIKICAgIC8vICMgSW5pdGlhbGl6ZSB0cmVhc3VyeSB3aXRoIGNyZWF0b3IncyBjb250cmlidXRpb24KICAgIC8vIHNlbGYudHJlYXN1cnlfYmFsYW5jZXNbZGFvX2lkX2J5dGVzXSA9IHBheW1lbnRfdHhuLmFtb3VudAogICAgYnl0ZWNfMyAvLyAweDc0NzI2NTYxNzM3NTcyNzk1ZgogICAgZGlnIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjExNAogICAgLy8gcmV0dXJuIFN0cmluZy5mcm9tX2J5dGVzKGRhb19pZF9ieXRlcykKICAgIHJldHN1YgoKY3JlYXRlX2Rhb19wcm9wb3NhbF9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzEgLy8gMAogICAgYiBjcmVhdGVfZGFvX3Byb3Bvc2FsX2Jvb2xfbWVyZ2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jaXRhZGVsX2Rhby5jb250cmFjdC5DaXRhZGVsREFPLmpvaW5fZGFvKGRhb19pZDogYnl0ZXMsIHBheW1lbnRfdHhuOiB1aW50NjQpIC0+IGJ5dGVzOgpqb2luX2RhbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToxMTYtMTIxCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBqb2luX2RhbygKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGRhb19pZDogU3RyaW5nLAogICAgLy8gICAgIHBheW1lbnRfdHhuOiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbgogICAgLy8gKSAtPiBTdHJpbmc6CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToxMzQtMTM1CiAgICAvLyAjIFZlcmlmeSBEQU8gZXhpc3RzIChzaW1wbGlmaWVkIGNoZWNrKQogICAgLy8gYXNzZXJ0IGRhb19pZF9ieXRlcyBpbiBzZWxmLmRhb19jb25maWdzLCAiREFPIGRvZXMgbm90IGV4aXN0IgogICAgYnl0ZWNfMiAvLyAweDY0NjE2ZjVmNjM2ZjZlNjY2OTY3NWYKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIERBTyBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjEzNgogICAgLy8gZGFvX2NvbmZpZyA9IHNlbGYuZGFvX2NvbmZpZ3NbZGFvX2lkX2J5dGVzXS5jb3B5KCkKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRhb19jb25maWdzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjEzOC0xMzkKICAgIC8vICMgVmVyaWZ5IHBheW1lbnQgdHJhbnNhY3Rpb24KICAgIC8vIGFzc2VydCBwYXltZW50X3R4bi5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCAiUGF5bWVudCBtdXN0IGJlIHRvIGNvbnRyYWN0IgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gUGF5bWVudCBtdXN0IGJlIHRvIGNvbnRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTQwCiAgICAvLyBhc3NlcnQgcGF5bWVudF90eG4uc2VuZGVyID09IFR4bi5zZW5kZXIsICJQYXltZW50IHNlbmRlciBtdXN0IG1hdGNoIHRyYW5zYWN0aW9uIHNlbmRlciIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgU2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICA9PQogICAgYXNzZXJ0IC8vIFBheW1lbnQgc2VuZGVyIG11c3QgbWF0Y2ggdHJhbnNhY3Rpb24gc2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTQxCiAgICAvLyBhc3NlcnQgcGF5bWVudF90eG4uYW1vdW50ID49IGRhb19jb25maWcubWluX3N0YWtlLm5hdGl2ZSwgIlBheW1lbnQgbXVzdCBtZWV0IG1pbmltdW0gc3Rha2UiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgc3dhcAogICAgcHVzaGludCA4IC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgMQogICAgPD0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgbWVldCBtaW5pbXVtIHN0YWtlCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTQzLTE0NAogICAgLy8gIyBDaGVjayBpZiBhbHJlYWR5IGEgbWVtYmVyCiAgICAvLyBtZW1iZXJfa2V5ID0gZGFvX2lkX2J5dGVzICsgVHhuLnNlbmRlci5ieXRlcwogICAgZnJhbWVfZGlnIC0yCiAgICB0eG4gU2VuZGVyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToxNDUKICAgIC8vIGV4aXN0aW5nX3N0YWtlLCBpc19tZW1iZXIgPSBzZWxmLm1lbWJlcl9zdGFrZXMubWF5YmUobWVtYmVyX2tleSkKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE2YjY1NWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfZ2V0CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToxNDYKICAgIC8vIGFzc2VydCBub3QgaXNfbWVtYmVyLCAiQWxyZWFkeSBhIG1lbWJlciBvZiB0aGlzIERBTyIKICAgICEKICAgIGFzc2VydCAvLyBBbHJlYWR5IGEgbWVtYmVyIG9mIHRoaXMgREFPCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTQ4LTE0OQogICAgLy8gIyBSZWNvcmQgbWVtYmVyc2hpcCBhbmQgc3Rha2UKICAgIC8vIHNlbGYubWVtYmVyX3N0YWtlc1ttZW1iZXJfa2V5XSA9IHBheW1lbnRfdHhuLmFtb3VudAogICAgZGlnIDEKICAgIGl0b2IKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToxNTEtMTUyCiAgICAvLyAjIEFkZCB0byB0cmVhc3VyeQogICAgLy8gY3VycmVudF90cmVhc3VyeSA9IHNlbGYudHJlYXN1cnlfYmFsYW5jZXNbZGFvX2lkX2J5dGVzXQogICAgYnl0ZWNfMyAvLyAweDc0NzI2NTYxNzM3NTcyNzk1ZgogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudHJlYXN1cnlfYmFsYW5jZXMgZW50cnkgZXhpc3RzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTUzCiAgICAvLyBzZWxmLnRyZWFzdXJ5X2JhbGFuY2VzW2Rhb19pZF9ieXRlc10gPSBjdXJyZW50X3RyZWFzdXJ5ICsgcGF5bWVudF90eG4uYW1vdW50CiAgICB1bmNvdmVyIDIKICAgICsKICAgIGl0b2IKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToxNTUKICAgIC8vIHJldHVybiBTdHJpbmcoIlN1Y2Nlc3NmdWxseSBqb2luZWQgREFPOiAiKSArIGRhb19pZAogICAgcHVzaGJ5dGVzICJTdWNjZXNzZnVsbHkgam9pbmVkIERBTzogIgogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jaXRhZGVsX2Rhby5jb250cmFjdC5DaXRhZGVsREFPLmNyZWF0ZV9wcm9wb3NhbChkYW9faWQ6IGJ5dGVzLCBwcm9wb3NhbF90aXRsZTogYnl0ZXMsIHByb3Bvc2FsX2Rlc2NyaXB0aW9uOiBieXRlcywgbW9kZXJhdG9yX2NhdGVnb3J5OiBieXRlcykgLT4gYnl0ZXM6CmNyZWF0ZV9wcm9wb3NhbDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToxNTctMTY0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjcmVhdGVfcHJvcG9zYWwoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkYW9faWQ6IFN0cmluZywKICAgIC8vICAgICBwcm9wb3NhbF90aXRsZTogU3RyaW5nLAogICAgLy8gICAgIHByb3Bvc2FsX2Rlc2NyaXB0aW9uOiBTdHJpbmcsCiAgICAvLyAgICAgbW9kZXJhdG9yX2NhdGVnb3J5OiBTdHJpbmcsCiAgICAvLyApIC0+IFN0cmluZzoKICAgIHByb3RvIDQgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjE3OS0xODAKICAgIC8vICMgVmVyaWZ5IERBTyBleGlzdHMgKHNpbXBsaWZpZWQgY2hlY2spCiAgICAvLyBhc3NlcnQgZGFvX2lkX2J5dGVzIGluIHNlbGYuZGFvX2NvbmZpZ3MsICJEQU8gZG9lcyBub3QgZXhpc3QiCiAgICBieXRlY18yIC8vIDB4NjQ2MTZmNWY2MzZmNmU2NjY5Njc1ZgogICAgZnJhbWVfZGlnIC00CiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gREFPIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTgxCiAgICAvLyBkYW9fY29uZmlnID0gc2VsZi5kYW9fY29uZmlnc1tkYW9faWRfYnl0ZXNdLmNvcHkoKQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGFvX2NvbmZpZ3MgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTgzLTE4NAogICAgLy8gIyBWZXJpZnkgc2VuZGVyIGlzIERBTyBtZW1iZXIKICAgIC8vIG1lbWJlcl9rZXkgPSBkYW9faWRfYnl0ZXMgKyBUeG4uc2VuZGVyLmJ5dGVzCiAgICBmcmFtZV9kaWcgLTQKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjE4NQogICAgLy8gbWVtYmVyX3N0YWtlLCBpc19tZW1iZXIgPSBzZWxmLm1lbWJlcl9zdGFrZXMubWF5YmUobWVtYmVyX2tleSkKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE2YjY1NWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTg2CiAgICAvLyBhc3NlcnQgaXNfbWVtYmVyLCAiT25seSBEQU8gbWVtYmVycyBjYW4gY3JlYXRlIHByb3Bvc2FscyIKICAgIGFzc2VydCAvLyBPbmx5IERBTyBtZW1iZXJzIGNhbiBjcmVhdGUgcHJvcG9zYWxzCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTg4LTE4OQogICAgLy8gIyBHZW5lcmF0ZSB1bmlxdWUgcHJvcG9zYWwgSUQKICAgIC8vIHNlbGYucHJvcG9zYWxfY291bnRlci52YWx1ZSArPSBVSW50NjQoMSkKICAgIGludGNfMSAvLyAwCiAgICBieXRlYyA2IC8vICJwcm9wb3NhbF9jb3VudGVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnByb3Bvc2FsX2NvdW50ZXIgZXhpc3RzCiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgYnl0ZWMgNiAvLyAicHJvcG9zYWxfY291bnRlciIKICAgIGRpZyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjE5MAogICAgLy8gcHJvcG9zYWxfaWRfYnl0ZXMgPSBvcC5jb25jYXQoQnl0ZXMoYiJwcm9wXyIpLCBvcC5pdG9iKHNlbGYucHJvcG9zYWxfY291bnRlci52YWx1ZSkpCiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHg3MDcyNmY3MDVmCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToxOTItMTk0CiAgICAvLyAjIENhbGN1bGF0ZSByZXF1aXJlZCB2b3RlcyBiYXNlZCBvbiB0aHJlc2hvbGQKICAgIC8vICMgRm9yIHNpbXBsaWNpdHksIHdlJ2xsIHVzZSB0aGUgbWluaW11bSBtZW1iZXJzIGFzIGJhc2UKICAgIC8vIHJlcXVpcmVkX3ZvdGVzID0gKGRhb19jb25maWcubWluX21lbWJlcnMubmF0aXZlICogZGFvX2NvbmZpZy5hY3RpdmF0aW9uX3RocmVzaG9sZC5uYXRpdmUpIC8vIFVJbnQ2NCgxMDApCiAgICBkaWcgMQogICAgaW50Y18xIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICAqCiAgICBwdXNoaW50IDEwMCAvLyAxMDAKICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyMDEKICAgIC8vIGNyZWF0b3I9QWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyMDIKICAgIC8vIHJlcXVpcmVkX3ZvdGVzPUFSQzRVSW50NjQocmVxdWlyZWRfdm90ZXMpLAogICAgc3dhcAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjIwNQogICAgLy8gY3JlYXRlZF9hdD1BUkM0VUludDY0KEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wKQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjE5Ni0yMDYKICAgIC8vICMgU3RvcmUgcHJvcG9zYWwgZGF0YQogICAgLy8gcHJvcG9zYWxfZGF0YSA9IFByb3Bvc2FsRGF0YSgKICAgIC8vICAgICBkYW9faWQ9QVJDNFN0cmluZy5mcm9tX2J5dGVzKGRhb19pZF9ieXRlcyksCiAgICAvLyAgICAgdGl0bGU9QVJDNFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX3RpdGxlLmJ5dGVzKSwKICAgIC8vICAgICBkZXNjcmlwdGlvbj1BUkM0U3RyaW5nLmZyb21fYnl0ZXMocHJvcG9zYWxfZGVzY3JpcHRpb24uYnl0ZXMpLAogICAgLy8gICAgIGNyZWF0b3I9QWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICByZXF1aXJlZF92b3Rlcz1BUkM0VUludDY0KHJlcXVpcmVkX3ZvdGVzKSwKICAgIC8vICAgICBjdXJyZW50X3ZvdGVzPUFSQzRVSW50NjQoMCksCiAgICAvLyAgICAgc3RhdHVzPUFSQzRTdHJpbmcuZnJvbV9ieXRlcyhCeXRlcyhiImFjdGl2ZSIpKSwKICAgIC8vICAgICBjcmVhdGVkX2F0PUFSQzRVSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApCiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTQKICAgIGxlbgogICAgcHVzaGludCA2NCAvLyA2NAogICAgKwogICAgZHVwCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcHVzaGJ5dGVzIDB4MDA0MAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTMKICAgIGxlbgogICAgdW5jb3ZlciAyCiAgICArCiAgICBkdXAKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0yCiAgICBsZW4KICAgIHVuY292ZXIgMgogICAgKwogICAgc3dhcAogICAgdW5jb3ZlciA0CiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjAzCiAgICAvLyBjdXJyZW50X3ZvdGVzPUFSQzRVSW50NjQoMCksCiAgICBwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDAwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MTk2LTIwNgogICAgLy8gIyBTdG9yZSBwcm9wb3NhbCBkYXRhCiAgICAvLyBwcm9wb3NhbF9kYXRhID0gUHJvcG9zYWxEYXRhKAogICAgLy8gICAgIGRhb19pZD1BUkM0U3RyaW5nLmZyb21fYnl0ZXMoZGFvX2lkX2J5dGVzKSwKICAgIC8vICAgICB0aXRsZT1BUkM0U3RyaW5nLmZyb21fYnl0ZXMocHJvcG9zYWxfdGl0bGUuYnl0ZXMpLAogICAgLy8gICAgIGRlc2NyaXB0aW9uPUFSQzRTdHJpbmcuZnJvbV9ieXRlcyhwcm9wb3NhbF9kZXNjcmlwdGlvbi5ieXRlcyksCiAgICAvLyAgICAgY3JlYXRvcj1BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIHJlcXVpcmVkX3ZvdGVzPUFSQzRVSW50NjQocmVxdWlyZWRfdm90ZXMpLAogICAgLy8gICAgIGN1cnJlbnRfdm90ZXM9QVJDNFVJbnQ2NCgwKSwKICAgIC8vICAgICBzdGF0dXM9QVJDNFN0cmluZy5mcm9tX2J5dGVzKEJ5dGVzKGIiYWN0aXZlIikpLAogICAgLy8gICAgIGNyZWF0ZWRfYXQ9QVJDNFVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCkKICAgIC8vICkKICAgIGNvbmNhdAogICAgc3dhcAogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTQKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0zCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjA0CiAgICAvLyBzdGF0dXM9QVJDNFN0cmluZy5mcm9tX2J5dGVzKEJ5dGVzKGIiYWN0aXZlIikpLAogICAgYnl0ZWMgNyAvLyAweDYxNjM3NDY5NzY2NQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjE5Ni0yMDYKICAgIC8vICMgU3RvcmUgcHJvcG9zYWwgZGF0YQogICAgLy8gcHJvcG9zYWxfZGF0YSA9IFByb3Bvc2FsRGF0YSgKICAgIC8vICAgICBkYW9faWQ9QVJDNFN0cmluZy5mcm9tX2J5dGVzKGRhb19pZF9ieXRlcyksCiAgICAvLyAgICAgdGl0bGU9QVJDNFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX3RpdGxlLmJ5dGVzKSwKICAgIC8vICAgICBkZXNjcmlwdGlvbj1BUkM0U3RyaW5nLmZyb21fYnl0ZXMocHJvcG9zYWxfZGVzY3JpcHRpb24uYnl0ZXMpLAogICAgLy8gICAgIGNyZWF0b3I9QWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICByZXF1aXJlZF92b3Rlcz1BUkM0VUludDY0KHJlcXVpcmVkX3ZvdGVzKSwKICAgIC8vICAgICBjdXJyZW50X3ZvdGVzPUFSQzRVSW50NjQoMCksCiAgICAvLyAgICAgc3RhdHVzPUFSQzRTdHJpbmcuZnJvbV9ieXRlcyhCeXRlcyhiImFjdGl2ZSIpKSwKICAgIC8vICAgICBjcmVhdGVkX2F0PUFSQzRVSW50NjQoR2xvYmFsLmxhdGVzdF90aW1lc3RhbXApCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyMDcKICAgIC8vIHNlbGYucHJvcG9zYWxzW3Byb3Bvc2FsX2lkX2J5dGVzXSA9IHByb3Bvc2FsX2RhdGEuY29weSgpCiAgICBieXRlYyA0IC8vIDB4NzA3MjZmNzA2ZjczNjE2YzVmCiAgICBkaWcgMgogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9kZWwKICAgIHBvcAogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjIwOQogICAgLy8gcmV0dXJuIFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX2lkX2J5dGVzKQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNpdGFkZWxfZGFvLmNvbnRyYWN0LkNpdGFkZWxEQU8udm90ZV9vbl9wcm9wb3NhbChwcm9wb3NhbF9pZDogYnl0ZXMsIHZvdGVfeWVzOiBieXRlcykgLT4gYnl0ZXM6CnZvdGVfb25fcHJvcG9zYWw6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjExLTIxNgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgdm90ZV9vbl9wcm9wb3NhbCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHByb3Bvc2FsX2lkOiBTdHJpbmcsCiAgICAvLyAgICAgdm90ZV95ZXM6IEJvb2wsCiAgICAvLyApIC0+IFN0cmluZzoKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjIyOS0yMzAKICAgIC8vICMgVmVyaWZ5IHByb3Bvc2FsIGV4aXN0cyAoc2ltcGxpZmllZCBjaGVjaykKICAgIC8vIGFzc2VydCBwcm9wb3NhbF9pZF9ieXRlcyBpbiBzZWxmLnByb3Bvc2FscywgIlByb3Bvc2FsIGRvZXMgbm90IGV4aXN0IgogICAgYnl0ZWMgNCAvLyAweDcwNzI2ZjcwNmY3MzYxNmM1ZgogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIGR1cG4gMgogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gUHJvcG9zYWwgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyMzEKICAgIC8vIHByb3Bvc2FsX2RhdGEgPSBzZWxmLnByb3Bvc2Fsc1twcm9wb3NhbF9pZF9ieXRlc10uY29weSgpCiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucHJvcG9zYWxzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjIzMgogICAgLy8gYXNzZXJ0IHByb3Bvc2FsX2RhdGEuc3RhdHVzLmJ5dGVzID09IEJ5dGVzKGIiYWN0aXZlIiksICJQcm9wb3NhbCBpcyBub3QgYWN0aXZlIgogICAgZHVwCiAgICBpbnRjXzMgLy8gNTQKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgbGVuCiAgICBkaWcgMgogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgYnl0ZWMgNyAvLyAweDYxNjM3NDY5NzY2NQogICAgPT0KICAgIGFzc2VydCAvLyBQcm9wb3NhbCBpcyBub3QgYWN0aXZlCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjM0LTIzNQogICAgLy8gIyBWZXJpZnkgc2VuZGVyIGlzIERBTyBtZW1iZXIKICAgIC8vIGRhb19pZF9ieXRlcyA9IHByb3Bvc2FsX2RhdGEuZGFvX2lkLmJ5dGVzCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDEKICAgIGludGNfMiAvLyAyCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDIKICAgIGNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyMzYKICAgIC8vIG1lbWJlcl9rZXkgPSBkYW9faWRfYnl0ZXMgKyBUeG4uc2VuZGVyLmJ5dGVzCiAgICB0eG4gU2VuZGVyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyMzcKICAgIC8vIG1lbWJlcl9zdGFrZSwgaXNfbWVtYmVyID0gc2VsZi5tZW1iZXJfc3Rha2VzLm1heWJlKG1lbWJlcl9rZXkpCiAgICBieXRlY18xIC8vIDB4NzM3NDYxNmI2NTVmCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjIzOAogICAgLy8gYXNzZXJ0IGlzX21lbWJlciwgIk9ubHkgREFPIG1lbWJlcnMgY2FuIHZvdGUiCiAgICBhc3NlcnQgLy8gT25seSBEQU8gbWVtYmVycyBjYW4gdm90ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI0MC0yNDEKICAgIC8vICMgQ2hlY2sgaWYgYWxyZWFkeSB2b3RlZAogICAgLy8gdm90ZV9rZXkgPSBwcm9wb3NhbF9pZF9ieXRlcyArIFR4bi5zZW5kZXIuYnl0ZXMKICAgIGZyYW1lX2RpZyAtMgogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjQyCiAgICAvLyBleGlzdGluZ192b3RlLCBoYXNfdm90ZWQgPSBzZWxmLnZvdGVzLm1heWJlKHZvdGVfa2V5KQogICAgcHVzaGJ5dGVzIDB4NzY2Zjc0NjU1ZgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9nZXQKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI0MwogICAgLy8gYXNzZXJ0IG5vdCBoYXNfdm90ZWQsICJBbHJlYWR5IHZvdGVkIG9uIHRoaXMgcHJvcG9zYWwiCiAgICAhCiAgICBhc3NlcnQgLy8gQWxyZWFkeSB2b3RlZCBvbiB0aGlzIHByb3Bvc2FsCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjQ1LTI0NgogICAgLy8gIyBSZWNvcmQgdm90ZSAoMSA9IHllcywgMiA9IG5vKQogICAgLy8gdm90ZV92YWx1ZSA9IFVJbnQ2NCgxKSBpZiB2b3RlX3llcyBlbHNlIFVJbnQ2NCgyKQogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoYnl0ZXMgMHgwMAogICAgIT0KICAgIGR1cAogICAgY292ZXIgMwogICAgaW50Y18yIC8vIDIKICAgIGludGNfMCAvLyAxCiAgICBkaWcgMgogICAgc2VsZWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjQ3CiAgICAvLyBzZWxmLnZvdGVzW3ZvdGVfa2V5XSA9IHZvdGVfdmFsdWUKICAgIGl0b2IKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI0OS0yNTAKICAgIC8vICMgVXBkYXRlIHZvdGUgY291bnQgKG9ubHkgY291bnQgeWVzIHZvdGVzKQogICAgLy8gaWYgdm90ZV95ZXM6CiAgICBieiB2b3RlX29uX3Byb3Bvc2FsX2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI1MQogICAgLy8gcHJvcG9zYWxfZGF0YS5jdXJyZW50X3ZvdGVzID0gQVJDNFVJbnQ2NChwcm9wb3NhbF9kYXRhLmN1cnJlbnRfdm90ZXMubmF0aXZlICsgVUludDY0KDEpKQogICAgZnJhbWVfZGlnIDEKICAgIGR1cAogICAgcHVzaGludCA0NiAvLyA0NgogICAgZXh0cmFjdF91aW50NjQKICAgIGludGNfMCAvLyAxCiAgICArCiAgICBpdG9iCiAgICByZXBsYWNlMiA0NgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyNTMtMjU0CiAgICAvLyAjIENoZWNrIGlmIHByb3Bvc2FsIHBhc3NlcwogICAgLy8gaWYgcHJvcG9zYWxfZGF0YS5jdXJyZW50X3ZvdGVzLm5hdGl2ZSA+PSBwcm9wb3NhbF9kYXRhLnJlcXVpcmVkX3ZvdGVzLm5hdGl2ZToKICAgIGR1cAogICAgcHVzaGludCA0NiAvLyA0NgogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAxCiAgICBwdXNoaW50IDM4IC8vIDM4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgPj0KICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMwogICAgYnogdm90ZV9vbl9wcm9wb3NhbF9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyNTUKICAgIC8vIHByb3Bvc2FsX2RhdGEuc3RhdHVzID0gQVJDNFN0cmluZy5mcm9tX2J5dGVzKEJ5dGVzKGIicGFzc2VkIikpCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBpbnRjXzMgLy8gNTQKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gMAogICAgc3dhcAogICAgZXh0cmFjdDMKICAgIGJ5dGVjIDggLy8gMHg3MDYxNzM3MzY1NjQKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAzCgp2b3RlX29uX3Byb3Bvc2FsX2FmdGVyX2lmX2Vsc2VANDoKICAgIGZyYW1lX2RpZyAzCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI1Ny0yNTgKICAgIC8vICMgVXBkYXRlIHByb3Bvc2FsIGRhdGEKICAgIC8vIHNlbGYucHJvcG9zYWxzW3Byb3Bvc2FsX2lkX2J5dGVzXSA9IHByb3Bvc2FsX2RhdGEuY29weSgpCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyNjAKICAgIC8vIHZvdGVfdHlwZSA9IFN0cmluZygieWVzIikgaWYgdm90ZV95ZXMgZWxzZSBTdHJpbmcoIm5vIikKICAgIGZyYW1lX2RpZyAyCiAgICBieiB2b3RlX29uX3Byb3Bvc2FsX3Rlcm5hcnlfZmFsc2VANgogICAgcHVzaGJ5dGVzICJ5ZXMiCgp2b3RlX29uX3Byb3Bvc2FsX3Rlcm5hcnlfbWVyZ2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyNjEKICAgIC8vIHJldHVybiBTdHJpbmcoIlZvdGUgY2FzdDogIikgKyB2b3RlX3R5cGUgKyBTdHJpbmcoIiwgVG90YWwgeWVzIHZvdGVzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKG9wLml0b2IocHJvcG9zYWxfZGF0YS5jdXJyZW50X3ZvdGVzLm5hdGl2ZSkpCiAgICBwdXNoYnl0ZXMgIlZvdGUgY2FzdDogIgogICAgc3dhcAogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgIiwgVG90YWwgeWVzIHZvdGVzOiAiCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAxCiAgICBwdXNoaW50IDQ2IC8vIDQ2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgaXRvYgogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKdm90ZV9vbl9wcm9wb3NhbF90ZXJuYXJ5X2ZhbHNlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjYwCiAgICAvLyB2b3RlX3R5cGUgPSBTdHJpbmcoInllcyIpIGlmIHZvdGVfeWVzIGVsc2UgU3RyaW5nKCJubyIpCiAgICBwdXNoYnl0ZXMgIm5vIgogICAgYiB2b3RlX29uX3Byb3Bvc2FsX3Rlcm5hcnlfbWVyZ2VANwoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jaXRhZGVsX2Rhby5jb250cmFjdC5DaXRhZGVsREFPLmV4ZWN1dGVfcHJvcG9zYWwocHJvcG9zYWxfaWQ6IGJ5dGVzLCBtb2RlcmF0b3JfbmFtZTogYnl0ZXMpIC0+IHVpbnQ2NDoKZXhlY3V0ZV9wcm9wb3NhbDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyNjMtMjY4CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBleGVjdXRlX3Byb3Bvc2FsKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgcHJvcG9zYWxfaWQ6IFN0cmluZywKICAgIC8vICAgICBtb2RlcmF0b3JfbmFtZTogU3RyaW5nLAogICAgLy8gKSAtPiBVSW50NjQ6CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyODEtMjgyCiAgICAvLyAjIFZlcmlmeSBwcm9wb3NhbCBleGlzdHMgYW5kIGhhcyBwYXNzZWQgKHNpbXBsaWZpZWQgY2hlY2spCiAgICAvLyBhc3NlcnQgcHJvcG9zYWxfaWRfYnl0ZXMgaW4gc2VsZi5wcm9wb3NhbHMsICJQcm9wb3NhbCBkb2VzIG5vdCBleGlzdCIKICAgIGJ5dGVjIDQgLy8gMHg3MDcyNmY3MDZmNzM2MTZjNWYKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIFByb3Bvc2FsIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjgzCiAgICAvLyBwcm9wb3NhbF9kYXRhID0gc2VsZi5wcm9wb3NhbHNbcHJvcG9zYWxfaWRfYnl0ZXNdLmNvcHkoKQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5wcm9wb3NhbHMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6Mjg0CiAgICAvLyBhc3NlcnQgcHJvcG9zYWxfZGF0YS5zdGF0dXMuYnl0ZXMgPT0gQnl0ZXMoYiJwYXNzZWQiKSwgIlByb3Bvc2FsIGhhcyBub3QgcGFzc2VkIgogICAgZHVwCiAgICBpbnRjXzMgLy8gNTQKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgbGVuCiAgICBkaWcgMgogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgYnl0ZWMgOCAvLyAweDcwNjE3MzczNjU2NAogICAgPT0KICAgIGFzc2VydCAvLyBQcm9wb3NhbCBoYXMgbm90IHBhc3NlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI4Ni0yODcKICAgIC8vICMgVmVyaWZ5IHNlbmRlciBpcyBwcm9wb3NhbCBjcmVhdG9yIG9yIERBTyBtZW1iZXIKICAgIC8vIGRhb19pZF9ieXRlcyA9IHByb3Bvc2FsX2RhdGEuZGFvX2lkLmJ5dGVzCiAgICBkaWcgMQogICAgaW50Y18xIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMgogICAgaW50Y18yIC8vIDIKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMwogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI4OAogICAgLy8gbWVtYmVyX2tleSA9IGRhb19pZF9ieXRlcyArIFR4bi5zZW5kZXIuYnl0ZXMKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI4OQogICAgLy8gbWVtYmVyX3N0YWtlLCBpc19tZW1iZXIgPSBzZWxmLm1lbWJlcl9zdGFrZXMubWF5YmUobWVtYmVyX2tleSkKICAgIGJ5dGVjXzEgLy8gMHg3Mzc0NjE2YjY1NWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MjkwCiAgICAvLyBhc3NlcnQgaXNfbWVtYmVyLCAiT25seSBEQU8gbWVtYmVycyBjYW4gZXhlY3V0ZSBwcm9wb3NhbHMiCiAgICBhc3NlcnQgLy8gT25seSBEQU8gbWVtYmVycyBjYW4gZXhlY3V0ZSBwcm9wb3NhbHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weToyOTUKICAgIC8vIHByb3Bvc2FsX2RhdGEuZGVzY3JpcHRpb24uYnl0ZXMsCiAgICBkaWcgMQogICAgcHVzaGludCA0IC8vIDQKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMgogICAgc3dhcAogICAgZGlnIDIKICAgIHN1YnN0cmluZzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo0MzEtNDQ1CiAgICAvLyAjIENyZWF0ZSBBU0EgKE5GVCkgd2l0aCBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gIyBUaGUgYXNzZXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBtYW5hZ2VkIGJ5IHRoZSBzbWFydCBjb250cmFjdAogICAgLy8gaXR4bi5Bc3NldENvbmZpZygKICAgIC8vICAgICB0b3RhbD1VSW50NjQoMSksICAjIE5GVCAtIG9ubHkgMSB1bml0CiAgICAvLyAgICAgZGVjaW1hbHM9VUludDY0KDApLCAgIyBORlQgLSBubyBkZWNpbWFscwogICAgLy8gICAgIGRlZmF1bHRfZnJvemVuPUZhbHNlLAogICAgLy8gICAgIGFzc2V0X25hbWU9bW9kZXJhdG9yX25hbWUuYnl0ZXMsCiAgICAvLyAgICAgdW5pdF9uYW1lPUJ5dGVzKGIiQ0lUTU9EIiksCiAgICAvLyAgICAgdXJsPUJ5dGVzKGIiaHR0cHM6Ly9jaXRhZGVseC5haS9tb2RlcmF0b3IvIiksCiAgICAvLyAgICAgbWV0YWRhdGFfaGFzaD1vcC5zaGEyNTYoZGVzY3JpcHRpb24pLAogICAgLy8gICAgIG1hbmFnZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICByZXNlcnZlPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgZnJlZXplPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgY2xhd2JhY2s9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo0NDAKICAgIC8vIG1ldGFkYXRhX2hhc2g9b3Auc2hhMjU2KGRlc2NyaXB0aW9uKSwKICAgIHNoYTI1NgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjQ0MQogICAgLy8gbWFuYWdlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo0NDItNDQ0CiAgICAvLyByZXNlcnZlPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyBmcmVlemU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vIGNsYXdiYWNrPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBkdXBuIDMKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRDbGF3YmFjawogICAgaXR4bl9maWVsZCBDb25maWdBc3NldEZyZWV6ZQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldFJlc2VydmUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TWV0YWRhdGFIYXNoCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6NDM5CiAgICAvLyB1cmw9Qnl0ZXMoYiJodHRwczovL2NpdGFkZWx4LmFpL21vZGVyYXRvci8iKSwKICAgIHB1c2hieXRlcyAweDY4NzQ3NDcwNzMzYTJmMmY2MzY5NzQ2MTY0NjU2Yzc4MmU2MTY5MmY2ZDZmNjQ2NTcyNjE3NDZmNzIyZgogICAgaXR4bl9maWVsZCBDb25maWdBc3NldFVSTAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjQzOAogICAgLy8gdW5pdF9uYW1lPUJ5dGVzKGIiQ0lUTU9EIiksCiAgICBwdXNoYnl0ZXMgMHg0MzQ5NTQ0ZDRmNDQKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRVbml0TmFtZQogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TmFtZQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjQzNgogICAgLy8gZGVmYXVsdF9mcm96ZW49RmFsc2UsCiAgICBpbnRjXzEgLy8gMAogICAgaXR4bl9maWVsZCBDb25maWdBc3NldERlZmF1bHRGcm96ZW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo0MzUKICAgIC8vIGRlY2ltYWxzPVVJbnQ2NCgwKSwgICMgTkZUIC0gbm8gZGVjaW1hbHMKICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo0MzQKICAgIC8vIHRvdGFsPVVJbnQ2NCgxKSwgICMgTkZUIC0gb25seSAxIHVuaXQKICAgIGludGNfMCAvLyAxCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VG90YWwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo0MzEtNDMzCiAgICAvLyAjIENyZWF0ZSBBU0EgKE5GVCkgd2l0aCBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gIyBUaGUgYXNzZXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBtYW5hZ2VkIGJ5IHRoZSBzbWFydCBjb250cmFjdAogICAgLy8gaXR4bi5Bc3NldENvbmZpZygKICAgIHB1c2hpbnQgMyAvLyBhY2ZnCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTo0MzEtNDQ1CiAgICAvLyAjIENyZWF0ZSBBU0EgKE5GVCkgd2l0aCBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gIyBUaGUgYXNzZXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBtYW5hZ2VkIGJ5IHRoZSBzbWFydCBjb250cmFjdAogICAgLy8gaXR4bi5Bc3NldENvbmZpZygKICAgIC8vICAgICB0b3RhbD1VSW50NjQoMSksICAjIE5GVCAtIG9ubHkgMSB1bml0CiAgICAvLyAgICAgZGVjaW1hbHM9VUludDY0KDApLCAgIyBORlQgLSBubyBkZWNpbWFscwogICAgLy8gICAgIGRlZmF1bHRfZnJvemVuPUZhbHNlLAogICAgLy8gICAgIGFzc2V0X25hbWU9bW9kZXJhdG9yX25hbWUuYnl0ZXMsCiAgICAvLyAgICAgdW5pdF9uYW1lPUJ5dGVzKGIiQ0lUTU9EIiksCiAgICAvLyAgICAgdXJsPUJ5dGVzKGIiaHR0cHM6Ly9jaXRhZGVseC5haS9tb2RlcmF0b3IvIiksCiAgICAvLyAgICAgbWV0YWRhdGFfaGFzaD1vcC5zaGEyNTYoZGVzY3JpcHRpb24pLAogICAgLy8gICAgIG1hbmFnZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICByZXNlcnZlPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgZnJlZXplPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgY2xhd2JhY2s9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6NDQ3LTQ1MAogICAgLy8gIyBSZXR1cm4gYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNyZWF0ZWQgYXNzZXQKICAgIC8vICMgSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGJlIHRoZSBhY3R1YWwgYXNzZXQgSUQgZnJvbSB0aGUgdHJhbnNhY3Rpb24KICAgIC8vICMgRm9yIG5vdywgd2UgdXNlIGEgZGV0ZXJtaW5pc3RpYyB2YWx1ZSBiYXNlZCBvbiB0aGUgY29udHJhY3Qgc3RhdGUKICAgIC8vIHJldHVybiBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjI5OS0zMDAKICAgIC8vICMgTWFyayBwcm9wb3NhbCBhcyBleGVjdXRlZCAoY2hhbmdlIHN0YXR1cykKICAgIC8vIHByb3Bvc2FsX2RhdGEuc3RhdHVzID0gQVJDNFN0cmluZy5mcm9tX2J5dGVzKEJ5dGVzKGIiZXhlY3V0ZWQiKSkKICAgIHVuY292ZXIgMgogICAgaW50Y18xIC8vIDAKICAgIHVuY292ZXIgMwogICAgZXh0cmFjdDMKICAgIHB1c2hieXRlcyAweDY1Nzg2NTYzNzU3NDY1NjQKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjMwMQogICAgLy8gc2VsZi5wcm9wb3NhbHNbcHJvcG9zYWxfaWRfYnl0ZXNdID0gcHJvcG9zYWxfZGF0YS5jb3B5KCkKICAgIGRpZyAyCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjMwMwogICAgLy8gcmV0dXJuIG5mdF9hc3NldF9pZAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNpdGFkZWxfZGFvLmNvbnRyYWN0LkNpdGFkZWxEQU8uZGlzdHJpYnV0ZV9yZXZlbnVlKGRhb19pZDogYnl0ZXMsIHJldmVudWVfYW1vdW50OiB1aW50NjQpIC0+IGJ5dGVzOgpkaXN0cmlidXRlX3JldmVudWU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzA1LTMxMAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZGlzdHJpYnV0ZV9yZXZlbnVlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGFvX2lkOiBTdHJpbmcsCiAgICAvLyAgICAgcmV2ZW51ZV9hbW91bnQ6IFVJbnQ2NCwKICAgIC8vICkgLT4gU3RyaW5nOgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzIzLTMyNAogICAgLy8gIyBWZXJpZnkgREFPIGV4aXN0cyAoc2ltcGxpZmllZCBjaGVjaykKICAgIC8vIGFzc2VydCBkYW9faWRfYnl0ZXMgaW4gc2VsZi5kYW9fY29uZmlncywgIkRBTyBkb2VzIG5vdCBleGlzdCIKICAgIGJ5dGVjXzIgLy8gMHg2NDYxNmY1ZjYzNmY2ZTY2Njk2NzVmCiAgICBmcmFtZV9kaWcgLTIKICAgIGNvbmNhdAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gREFPIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzI2LTMyNwogICAgLy8gIyBBZGQgcmV2ZW51ZSB0byB0cmVhc3VyeSAoaW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBjb21lIGZyb20gZXh0ZXJuYWwgcGF5bWVudHMpCiAgICAvLyBjdXJyZW50X3RyZWFzdXJ5ID0gc2VsZi50cmVhc3VyeV9iYWxhbmNlc1tkYW9faWRfYnl0ZXNdCiAgICBieXRlY18zIC8vIDB4NzQ3MjY1NjE3Mzc1NzI3OTVmCiAgICBmcmFtZV9kaWcgLTIKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50cmVhc3VyeV9iYWxhbmNlcyBlbnRyeSBleGlzdHMKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozMjgKICAgIC8vIHNlbGYudHJlYXN1cnlfYmFsYW5jZXNbZGFvX2lkX2J5dGVzXSA9IGN1cnJlbnRfdHJlYXN1cnkgKyByZXZlbnVlX2Ftb3VudAogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICBpdG9iCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzMzCiAgICAvLyByZXR1cm4gU3RyaW5nKCJSZXZlbnVlIGFkZGVkIHRvIHRyZWFzdXJ5IGZvciBEQU86ICIpICsgZGFvX2lkCiAgICBwdXNoYnl0ZXMgIlJldmVudWUgYWRkZWQgdG8gdHJlYXN1cnkgZm9yIERBTzogIgogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jaXRhZGVsX2Rhby5jb250cmFjdC5DaXRhZGVsREFPLmdldF9kYW9faW5mbyhkYW9faWQ6IGJ5dGVzKSAtPiBieXRlczoKZ2V0X2Rhb19pbmZvOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjMzNS0zMzYKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfZGFvX2luZm8oc2VsZiwgZGFvX2lkOiBTdHJpbmcpIC0+IFN0cmluZzoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM0OAogICAgLy8gaWYgZGFvX2lkX2J5dGVzIG5vdCBpbiBzZWxmLmRhb19jb25maWdzOgogICAgYnl0ZWNfMiAvLyAweDY0NjE2ZjVmNjM2ZjZlNjY2OTY3NWYKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYm56IGdldF9kYW9faW5mb19hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNDkKICAgIC8vIHJldHVybiBTdHJpbmcoIkRBTyBub3QgZm91bmQiKQogICAgcHVzaGJ5dGVzICJEQU8gbm90IGZvdW5kIgogICAgc3dhcAogICAgcmV0c3ViCgpnZXRfZGFvX2luZm9fYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM1MQogICAgLy8gZGFvX2NvbmZpZyA9IHNlbGYuZGFvX2NvbmZpZ3NbZGFvX2lkX2J5dGVzXS5jb3B5KCkKICAgIGZyYW1lX2RpZyAwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kYW9fY29uZmlncyBlbnRyeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNTIKICAgIC8vIHRyZWFzdXJ5X2JhbGFuY2UgPSBzZWxmLnRyZWFzdXJ5X2JhbGFuY2VzW2Rhb19pZF9ieXRlc10KICAgIGJ5dGVjXzMgLy8gMHg3NDcyNjU2MTczNzU3Mjc5NWYKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi50cmVhc3VyeV9iYWxhbmNlcyBlbnRyeSBleGlzdHMKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNTQKICAgIC8vIHJldHVybiAoU3RyaW5nKCJEQU86ICIpICsgZGFvX2lkICsKICAgIHB1c2hieXRlcyAiREFPOiAiCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM1NQogICAgLy8gU3RyaW5nKCIsIE1pbiBNZW1iZXJzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKG9wLml0b2IoZGFvX2NvbmZpZy5taW5fbWVtYmVycy5uYXRpdmUpKSArCiAgICBwdXNoYnl0ZXMgIiwgTWluIE1lbWJlcnM6ICIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNTQtMzU1CiAgICAvLyByZXR1cm4gKFN0cmluZygiREFPOiAiKSArIGRhb19pZCArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBNaW4gTWVtYmVyczogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKGRhb19jb25maWcubWluX21lbWJlcnMubmF0aXZlKSkgKwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzU1CiAgICAvLyBTdHJpbmcoIiwgTWluIE1lbWJlcnM6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMob3AuaXRvYihkYW9fY29uZmlnLm1pbl9tZW1iZXJzLm5hdGl2ZSkpICsKICAgIGRpZyAyCiAgICBpbnRjXzEgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNTQtMzU1CiAgICAvLyByZXR1cm4gKFN0cmluZygiREFPOiAiKSArIGRhb19pZCArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBNaW4gTWVtYmVyczogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKGRhb19jb25maWcubWluX21lbWJlcnMubmF0aXZlKSkgKwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzU2CiAgICAvLyBTdHJpbmcoIiwgTWluIFN0YWtlOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKG9wLml0b2IoZGFvX2NvbmZpZy5taW5fc3Rha2UubmF0aXZlKSkgKwogICAgcHVzaGJ5dGVzICIsIE1pbiBTdGFrZTogIgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM1NC0zNTYKICAgIC8vIHJldHVybiAoU3RyaW5nKCJEQU86ICIpICsgZGFvX2lkICsKICAgIC8vICAgICAgICAgU3RyaW5nKCIsIE1pbiBNZW1iZXJzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKG9wLml0b2IoZGFvX2NvbmZpZy5taW5fbWVtYmVycy5uYXRpdmUpKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBNaW4gU3Rha2U6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMob3AuaXRvYihkYW9fY29uZmlnLm1pbl9zdGFrZS5uYXRpdmUpKSArCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNTYKICAgIC8vIFN0cmluZygiLCBNaW4gU3Rha2U6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMob3AuaXRvYihkYW9fY29uZmlnLm1pbl9zdGFrZS5uYXRpdmUpKSArCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgOCAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM1NC0zNTYKICAgIC8vIHJldHVybiAoU3RyaW5nKCJEQU86ICIpICsgZGFvX2lkICsKICAgIC8vICAgICAgICAgU3RyaW5nKCIsIE1pbiBNZW1iZXJzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKG9wLml0b2IoZGFvX2NvbmZpZy5taW5fbWVtYmVycy5uYXRpdmUpKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBNaW4gU3Rha2U6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMob3AuaXRvYihkYW9fY29uZmlnLm1pbl9zdGFrZS5uYXRpdmUpKSArCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNTcKICAgIC8vIFN0cmluZygiLCBUcmVhc3VyeTogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKHRyZWFzdXJ5X2JhbGFuY2UpKSkKICAgIHB1c2hieXRlcyAiLCBUcmVhc3VyeTogIgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM1NC0zNTcKICAgIC8vIHJldHVybiAoU3RyaW5nKCJEQU86ICIpICsgZGFvX2lkICsKICAgIC8vICAgICAgICAgU3RyaW5nKCIsIE1pbiBNZW1iZXJzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKG9wLml0b2IoZGFvX2NvbmZpZy5taW5fbWVtYmVycy5uYXRpdmUpKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBNaW4gU3Rha2U6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMob3AuaXRvYihkYW9fY29uZmlnLm1pbl9zdGFrZS5uYXRpdmUpKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBUcmVhc3VyeTogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKHRyZWFzdXJ5X2JhbGFuY2UpKSkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM1NwogICAgLy8gU3RyaW5nKCIsIFRyZWFzdXJ5OiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKG9wLml0b2IodHJlYXN1cnlfYmFsYW5jZSkpKQogICAgc3dhcAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM1NC0zNTcKICAgIC8vIHJldHVybiAoU3RyaW5nKCJEQU86ICIpICsgZGFvX2lkICsKICAgIC8vICAgICAgICAgU3RyaW5nKCIsIE1pbiBNZW1iZXJzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKG9wLml0b2IoZGFvX2NvbmZpZy5taW5fbWVtYmVycy5uYXRpdmUpKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBNaW4gU3Rha2U6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMob3AuaXRvYihkYW9fY29uZmlnLm1pbl9zdGFrZS5uYXRpdmUpKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBUcmVhc3VyeTogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKHRyZWFzdXJ5X2JhbGFuY2UpKSkKICAgIGNvbmNhdAogICAgc3dhcAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNpdGFkZWxfZGFvLmNvbnRyYWN0LkNpdGFkZWxEQU8uZ2V0X3Byb3Bvc2FsX2luZm8ocHJvcG9zYWxfaWQ6IGJ5dGVzKSAtPiBieXRlczoKZ2V0X3Byb3Bvc2FsX2luZm86CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzU5LTM2MAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgLy8gZGVmIGdldF9wcm9wb3NhbF9pbmZvKHNlbGYsIHByb3Bvc2FsX2lkOiBTdHJpbmcpIC0+IFN0cmluZzoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM3MgogICAgLy8gaWYgcHJvcG9zYWxfaWRfYnl0ZXMgbm90IGluIHNlbGYucHJvcG9zYWxzOgogICAgYnl0ZWMgNCAvLyAweDcwNzI2ZjcwNmY3MzYxNmM1ZgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBibnogZ2V0X3Byb3Bvc2FsX2luZm9fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzczCiAgICAvLyByZXR1cm4gU3RyaW5nKCJQcm9wb3NhbCBub3QgZm91bmQiKQogICAgcHVzaGJ5dGVzICJQcm9wb3NhbCBub3QgZm91bmQiCiAgICBzd2FwCiAgICByZXRzdWIKCmdldF9wcm9wb3NhbF9pbmZvX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNzUKICAgIC8vIHByb3Bvc2FsX2RhdGEgPSBzZWxmLnByb3Bvc2Fsc1twcm9wb3NhbF9pZF9ieXRlc10uY29weSgpCiAgICBmcmFtZV9kaWcgMAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucHJvcG9zYWxzIGVudHJ5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM3NwogICAgLy8gcmV0dXJuIChTdHJpbmcoIlByb3Bvc2FsOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX2RhdGEudGl0bGUuYnl0ZXMpICsKICAgIGR1cAogICAgaW50Y18yIC8vIDIKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgcHVzaGludCA0IC8vIDQKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMgogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgcHVzaGJ5dGVzICJQcm9wb3NhbDogIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6Mzc4CiAgICAvLyBTdHJpbmcoIiwgU3RhdHVzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX2RhdGEuc3RhdHVzLmJ5dGVzKSArCiAgICBwdXNoYnl0ZXMgIiwgU3RhdHVzOiAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6Mzc3LTM3OAogICAgLy8gcmV0dXJuIChTdHJpbmcoIlByb3Bvc2FsOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX2RhdGEudGl0bGUuYnl0ZXMpICsKICAgIC8vICAgICAgICAgU3RyaW5nKCIsIFN0YXR1czogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhwcm9wb3NhbF9kYXRhLnN0YXR1cy5ieXRlcykgKwogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6Mzc4CiAgICAvLyBTdHJpbmcoIiwgU3RhdHVzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX2RhdGEuc3RhdHVzLmJ5dGVzKSArCiAgICBkaWcgMQogICAgaW50Y18zIC8vIDU0CiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDIKICAgIGxlbgogICAgZGlnIDMKICAgIGNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNzctMzc4CiAgICAvLyByZXR1cm4gKFN0cmluZygiUHJvcG9zYWw6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMocHJvcG9zYWxfZGF0YS50aXRsZS5ieXRlcykgKwogICAgLy8gICAgICAgICBTdHJpbmcoIiwgU3RhdHVzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX2RhdGEuc3RhdHVzLmJ5dGVzKSArCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNzkKICAgIC8vIFN0cmluZygiLCBWb3RlczogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKHByb3Bvc2FsX2RhdGEuY3VycmVudF92b3Rlcy5uYXRpdmUpKSArCiAgICBwdXNoYnl0ZXMgIiwgVm90ZXM6ICIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNzctMzc5CiAgICAvLyByZXR1cm4gKFN0cmluZygiUHJvcG9zYWw6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMocHJvcG9zYWxfZGF0YS50aXRsZS5ieXRlcykgKwogICAgLy8gICAgICAgICBTdHJpbmcoIiwgU3RhdHVzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX2RhdGEuc3RhdHVzLmJ5dGVzKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBWb3RlczogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKHByb3Bvc2FsX2RhdGEuY3VycmVudF92b3Rlcy5uYXRpdmUpKSArCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNzkKICAgIC8vIFN0cmluZygiLCBWb3RlczogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKHByb3Bvc2FsX2RhdGEuY3VycmVudF92b3Rlcy5uYXRpdmUpKSArCiAgICBkaWcgMQogICAgcHVzaGludCA0NiAvLyA0NgogICAgZXh0cmFjdF91aW50NjQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNzctMzc5CiAgICAvLyByZXR1cm4gKFN0cmluZygiUHJvcG9zYWw6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMocHJvcG9zYWxfZGF0YS50aXRsZS5ieXRlcykgKwogICAgLy8gICAgICAgICBTdHJpbmcoIiwgU3RhdHVzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX2RhdGEuc3RhdHVzLmJ5dGVzKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBWb3RlczogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKHByb3Bvc2FsX2RhdGEuY3VycmVudF92b3Rlcy5uYXRpdmUpKSArCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozODAKICAgIC8vIFN0cmluZygiLyIpICsgU3RyaW5nLmZyb21fYnl0ZXMob3AuaXRvYihwcm9wb3NhbF9kYXRhLnJlcXVpcmVkX3ZvdGVzLm5hdGl2ZSkpKQogICAgcHVzaGJ5dGVzICIvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM3Ny0zODAKICAgIC8vIHJldHVybiAoU3RyaW5nKCJQcm9wb3NhbDogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhwcm9wb3NhbF9kYXRhLnRpdGxlLmJ5dGVzKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBTdGF0dXM6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMocHJvcG9zYWxfZGF0YS5zdGF0dXMuYnl0ZXMpICsKICAgIC8vICAgICAgICAgU3RyaW5nKCIsIFZvdGVzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKG9wLml0b2IocHJvcG9zYWxfZGF0YS5jdXJyZW50X3ZvdGVzLm5hdGl2ZSkpICsKICAgIC8vICAgICAgICAgU3RyaW5nKCIvIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKHByb3Bvc2FsX2RhdGEucmVxdWlyZWRfdm90ZXMubmF0aXZlKSkpCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozODAKICAgIC8vIFN0cmluZygiLyIpICsgU3RyaW5nLmZyb21fYnl0ZXMob3AuaXRvYihwcm9wb3NhbF9kYXRhLnJlcXVpcmVkX3ZvdGVzLm5hdGl2ZSkpKQogICAgc3dhcAogICAgcHVzaGludCAzOCAvLyAzOAogICAgZXh0cmFjdF91aW50NjQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozNzctMzgwCiAgICAvLyByZXR1cm4gKFN0cmluZygiUHJvcG9zYWw6ICIpICsgU3RyaW5nLmZyb21fYnl0ZXMocHJvcG9zYWxfZGF0YS50aXRsZS5ieXRlcykgKwogICAgLy8gICAgICAgICBTdHJpbmcoIiwgU3RhdHVzOiAiKSArIFN0cmluZy5mcm9tX2J5dGVzKHByb3Bvc2FsX2RhdGEuc3RhdHVzLmJ5dGVzKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLCBWb3RlczogIikgKyBTdHJpbmcuZnJvbV9ieXRlcyhvcC5pdG9iKHByb3Bvc2FsX2RhdGEuY3VycmVudF92b3Rlcy5uYXRpdmUpKSArCiAgICAvLyAgICAgICAgIFN0cmluZygiLyIpICsgU3RyaW5nLmZyb21fYnl0ZXMob3AuaXRvYihwcm9wb3NhbF9kYXRhLnJlcXVpcmVkX3ZvdGVzLm5hdGl2ZSkpKQogICAgY29uY2F0CiAgICBzd2FwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2l0YWRlbF9kYW8uY29udHJhY3QuQ2l0YWRlbERBTy5jaGVja19tZW1iZXJzaGlwKGRhb19pZDogYnl0ZXMsIG1lbWJlcl9hZGRyZXNzOiBieXRlcykgLT4gYnl0ZXM6CmNoZWNrX21lbWJlcnNoaXA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6MzgyLTM4MwogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgLy8gZGVmIGNoZWNrX21lbWJlcnNoaXAoc2VsZiwgZGFvX2lkOiBTdHJpbmcsIG1lbWJlcl9hZGRyZXNzOiBBY2NvdW50KSAtPiBCb29sOgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2l0YWRlbF9kYW8vY29udHJhY3QucHk6Mzk1CiAgICAvLyBtZW1iZXJfa2V5ID0gZGFvX2lkX2J5dGVzICsgbWVtYmVyX2FkZHJlc3MuYnl0ZXMKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozOTYKICAgIC8vIG1lbWJlcl9zdGFrZSwgaXNfbWVtYmVyID0gc2VsZi5tZW1iZXJfc3Rha2VzLm1heWJlKG1lbWJlcl9rZXkpCiAgICBieXRlY18xIC8vIDB4NzM3NDYxNmI2NTVmCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjM5NwogICAgLy8gcmV0dXJuIEJvb2woaXNfbWVtYmVyKQogICAgcHVzaGJ5dGVzIDB4MDAKICAgIGludGNfMSAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNpdGFkZWxfZGFvLmNvbnRyYWN0LkNpdGFkZWxEQU8uZ2V0X3RyZWFzdXJ5X2JhbGFuY2UoZGFvX2lkOiBieXRlcykgLT4gdWludDY0OgpnZXRfdHJlYXN1cnlfYmFsYW5jZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXRhZGVsX2Rhby9jb250cmFjdC5weTozOTktNDAwCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgZ2V0X3RyZWFzdXJ5X2JhbGFuY2Uoc2VsZiwgZGFvX2lkOiBTdHJpbmcpIC0+IFVJbnQ2NDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpdGFkZWxfZGFvL2NvbnRyYWN0LnB5OjQxMQogICAgLy8gcmV0dXJuIHNlbGYudHJlYXN1cnlfYmFsYW5jZXNbZGFvX2lkX2J5dGVzXQogICAgYnl0ZWNfMyAvLyAweDc0NzI2NTYxNzM3NTcyNzk1ZgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRyZWFzdXJ5X2JhbGFuY2VzIGVudHJ5IGV4aXN0cwogICAgYnRvaQogICAgcmV0c3ViCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [768], "errorMessage": "Already a member of this DAO"}, {"pc": [1048], "errorMessage": "Already voted on this proposal"}, {"pc": [724, 828, 1376], "errorMessage": "DAO does not exist"}, {"pc": [633], "errorMessage": "Initial payment must meet minimum stake"}, {"pc": [574], "errorMessage": "Minimum 2 members required for DAO"}, {"pc": [582], "errorMessage": "Minimum stake must be at least 0.1 ALGO"}, {"pc": [196, 219, 247, 277, 307, 341, 370, 403, 451, 491], "errorMessage": "OnCompletion is not NoOp"}, {"pc": [842], "errorMessage": "Only DAO members can create proposals"}, {"pc": [1245], "errorMessage": "Only DAO members can execute proposals"}, {"pc": [1028], "errorMessage": "Only DAO members can vote"}, {"pc": [616, 734], "errorMessage": "Payment must be to contract"}, {"pc": [754], "errorMessage": "Payment must meet minimum stake"}, {"pc": [624, 742], "errorMessage": "Payment sender must match transaction sender"}, {"pc": [985, 1202], "errorMessage": "Proposal does not exist"}, {"pc": [1222], "errorMessage": "Proposal has not passed"}, {"pc": [1006], "errorMessage": "Proposal is not active"}, {"pc": [600], "errorMessage": "Threshold must be between 51-100"}, {"pc": [608], "errorMessage": "Voting period must be at least 1 day"}, {"pc": [564], "errorMessage": "can only call when creating"}, {"pc": [199, 222, 250, 280, 310, 344, 373, 406, 454, 494], "errorMessage": "can only call when not creating"}, {"pc": [726, 830, 1465], "errorMessage": "check self.dao_configs entry exists"}, {"pc": [638], "errorMessage": "check self.dao_counter exists"}, {"pc": [847], "errorMessage": "check self.proposal_counter exists"}, {"pc": [991, 1205, 1590], "errorMessage": "check self.proposals entry exists"}, {"pc": [779, 1383, 1471, 1705], "errorMessage": "check self.treasury_balances entry exists"}, {"pc": [470, 538], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class DaoConfig:
    """Struct for DAOConfig"""
    min_members: int
    min_stake: int
    voting_period: int
    activation_threshold: int
    creator: str

@dataclasses.dataclass(frozen=True)
class ProposalData:
    """Struct for ProposalData"""
    dao_id: str
    title: str
    description: str
    creator: str
    required_votes: int
    current_votes: int
    status: str
    created_at: int


@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateDaoProposalArgs:
    """Dataclass for create_dao_proposal arguments"""
    dao_name: str
    description: str
    category: str
    min_members: int
    min_stake: int
    voting_period: int
    activation_threshold: int
    payment_txn: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "create_dao_proposal(string,string,string,uint64,uint64,uint64,uint64,pay)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class JoinDaoArgs:
    """Dataclass for join_dao arguments"""
    dao_id: str
    payment_txn: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "join_dao(string,pay)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateProposalArgs:
    """Dataclass for create_proposal arguments"""
    dao_id: str
    proposal_title: str
    proposal_description: str
    moderator_category: str

    @property
    def abi_method_signature(self) -> str:
        return "create_proposal(string,string,string,string)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class VoteOnProposalArgs:
    """Dataclass for vote_on_proposal arguments"""
    proposal_id: str
    vote_yes: bool

    @property
    def abi_method_signature(self) -> str:
        return "vote_on_proposal(string,bool)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ExecuteProposalArgs:
    """Dataclass for execute_proposal arguments"""
    proposal_id: str
    moderator_name: str

    @property
    def abi_method_signature(self) -> str:
        return "execute_proposal(string,string)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class DistributeRevenueArgs:
    """Dataclass for distribute_revenue arguments"""
    dao_id: str
    revenue_amount: int

    @property
    def abi_method_signature(self) -> str:
        return "distribute_revenue(string,uint64)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetDaoInfoArgs:
    """Dataclass for get_dao_info arguments"""
    dao_id: str

    @property
    def abi_method_signature(self) -> str:
        return "get_dao_info(string)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetProposalInfoArgs:
    """Dataclass for get_proposal_info arguments"""
    proposal_id: str

    @property
    def abi_method_signature(self) -> str:
        return "get_proposal_info(string)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CheckMembershipArgs:
    """Dataclass for check_membership arguments"""
    dao_id: str
    member_address: str | bytes

    @property
    def abi_method_signature(self) -> str:
        return "check_membership(string,account)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetTreasuryBalanceArgs:
    """Dataclass for get_treasury_balance arguments"""
    dao_id: str

    @property
    def abi_method_signature(self) -> str:
        return "get_treasury_balance(string)uint64"


class CitadelDaoParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_dao_proposal(
        self,
        args: tuple[str, str, str, int, int, int, int, algokit_utils.AppMethodCallTransactionArgument] | CreateDaoProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_dao_proposal(string,string,string,uint64,uint64,uint64,uint64,pay)string",
            "args": method_args,
        }))

    def join_dao(
        self,
        args: tuple[str, algokit_utils.AppMethodCallTransactionArgument] | JoinDaoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "join_dao(string,pay)string",
            "args": method_args,
        }))

    def create_proposal(
        self,
        args: tuple[str, str, str, str] | CreateProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_proposal(string,string,string,string)string",
            "args": method_args,
        }))

    def vote_on_proposal(
        self,
        args: tuple[str, bool] | VoteOnProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vote_on_proposal(string,bool)string",
            "args": method_args,
        }))

    def execute_proposal(
        self,
        args: tuple[str, str] | ExecuteProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "execute_proposal(string,string)uint64",
            "args": method_args,
        }))

    def distribute_revenue(
        self,
        args: tuple[str, int] | DistributeRevenueArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "distribute_revenue(string,uint64)string",
            "args": method_args,
        }))

    def get_dao_info(
        self,
        args: tuple[str] | GetDaoInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_dao_info(string)string",
            "args": method_args,
        }))

    def get_proposal_info(
        self,
        args: tuple[str] | GetProposalInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_proposal_info(string)string",
            "args": method_args,
        }))

    def check_membership(
        self,
        args: tuple[str, str | bytes] | CheckMembershipArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "check_membership(string,account)bool",
            "args": method_args,
        }))

    def get_treasury_balance(
        self,
        args: tuple[str] | GetTreasuryBalanceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_treasury_balance(string)uint64",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class CitadelDaoCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_dao_proposal(
        self,
        args: tuple[str, str, str, int, int, int, int, algokit_utils.AppMethodCallTransactionArgument] | CreateDaoProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_dao_proposal(string,string,string,uint64,uint64,uint64,uint64,pay)string",
            "args": method_args,
        }))

    def join_dao(
        self,
        args: tuple[str, algokit_utils.AppMethodCallTransactionArgument] | JoinDaoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "join_dao(string,pay)string",
            "args": method_args,
        }))

    def create_proposal(
        self,
        args: tuple[str, str, str, str] | CreateProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_proposal(string,string,string,string)string",
            "args": method_args,
        }))

    def vote_on_proposal(
        self,
        args: tuple[str, bool] | VoteOnProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vote_on_proposal(string,bool)string",
            "args": method_args,
        }))

    def execute_proposal(
        self,
        args: tuple[str, str] | ExecuteProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "execute_proposal(string,string)uint64",
            "args": method_args,
        }))

    def distribute_revenue(
        self,
        args: tuple[str, int] | DistributeRevenueArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "distribute_revenue(string,uint64)string",
            "args": method_args,
        }))

    def get_dao_info(
        self,
        args: tuple[str] | GetDaoInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_dao_info(string)string",
            "args": method_args,
        }))

    def get_proposal_info(
        self,
        args: tuple[str] | GetProposalInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_proposal_info(string)string",
            "args": method_args,
        }))

    def check_membership(
        self,
        args: tuple[str, str | bytes] | CheckMembershipArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "check_membership(string,account)bool",
            "args": method_args,
        }))

    def get_treasury_balance(
        self,
        args: tuple[str] | GetTreasuryBalanceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_treasury_balance(string)uint64",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class CitadelDaoSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_dao_proposal(
        self,
        args: tuple[str, str, str, int, int, int, int, algokit_utils.AppMethodCallTransactionArgument] | CreateDaoProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_dao_proposal(string,string,string,uint64,uint64,uint64,uint64,pay)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def join_dao(
        self,
        args: tuple[str, algokit_utils.AppMethodCallTransactionArgument] | JoinDaoArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "join_dao(string,pay)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def create_proposal(
        self,
        args: tuple[str, str, str, str] | CreateProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_proposal(string,string,string,string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def vote_on_proposal(
        self,
        args: tuple[str, bool] | VoteOnProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "vote_on_proposal(string,bool)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def execute_proposal(
        self,
        args: tuple[str, str] | ExecuteProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "execute_proposal(string,string)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def distribute_revenue(
        self,
        args: tuple[str, int] | DistributeRevenueArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "distribute_revenue(string,uint64)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def get_dao_info(
        self,
        args: tuple[str] | GetDaoInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_dao_info(string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def get_proposal_info(
        self,
        args: tuple[str] | GetProposalInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_proposal_info(string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def check_membership(
        self,
        args: tuple[str, str | bytes] | CheckMembershipArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "check_membership(string,account)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def get_treasury_balance(
        self,
        args: tuple[str] | GetTreasuryBalanceArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_treasury_balance(string)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    dao_counter: int
    proposal_counter: int

class CitadelDaoState:
    """Methods to access state for the current CitadelDAO app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def dao_counter(self) -> int:
        """Get the current value of the dao_counter key in global_state state"""
        value = self.app_client.state.global_state.get_value("dao_counter")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def proposal_counter(self) -> int:
        """Get the current value of the proposal_counter key in global_state state"""
        value = self.app_client.state.global_state.get_value("proposal_counter")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {
            "DAOConfig": DaoConfig,
            "ProposalData": ProposalData
        }

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def dao_configs(self) -> "_MapState[bytes, DaoConfig]":
        """Get values from the dao_configs map in box state"""
        return _MapState(
            self.app_client.state.box,
            "dao_configs",
            self._struct_classes.get("DAOConfig")
        )

    @property
    def proposals(self) -> "_MapState[bytes, ProposalData]":
        """Get values from the proposals map in box state"""
        return _MapState(
            self.app_client.state.box,
            "proposals",
            self._struct_classes.get("ProposalData")
        )

    @property
    def member_stakes(self) -> "_MapState[bytes, int]":
        """Get values from the member_stakes map in box state"""
        return _MapState(
            self.app_client.state.box,
            "member_stakes",
            None
        )

    @property
    def votes(self) -> "_MapState[bytes, int]":
        """Get values from the votes map in box state"""
        return _MapState(
            self.app_client.state.box,
            "votes",
            None
        )

    @property
    def treasury_balances(self) -> "_MapState[bytes, int]":
        """Get values from the treasury_balances map in box state"""
        return _MapState(
            self.app_client.state.box,
            "treasury_balances",
            None
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class CitadelDaoClient:
    """Client for interacting with CitadelDAO smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = CitadelDaoParams(self.app_client)
        self.create_transaction = CitadelDaoCreateTransactionParams(self.app_client)
        self.send = CitadelDaoSend(self.app_client)
        self.state = CitadelDaoState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "CitadelDaoClient":
        return CitadelDaoClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "CitadelDaoClient":
        return CitadelDaoClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "CitadelDaoClient":
        return CitadelDaoClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "CitadelDaoComposer":
        return CitadelDaoComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_dao_proposal(string,string,string,uint64,uint64,uint64,uint64,pay)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["join_dao(string,pay)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_proposal(string,string,string,string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["vote_on_proposal(string,bool)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["execute_proposal(string,string)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["distribute_revenue(string,uint64)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_dao_info(string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_proposal_info(string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["check_membership(string,account)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_treasury_balance(string)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | bool | int | str:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class CitadelDaoBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating CitadelDao contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class CitadelDaoFactory(algokit_utils.TypedAppFactoryProtocol[CitadelDaoBareCallCreateParams, None, None]):
    """Factory for deploying and managing CitadelDaoClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = CitadelDaoFactoryParams(self.app_factory)
        self.create_transaction = CitadelDaoFactoryCreateTransaction(self.app_factory)
        self.send = CitadelDaoFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: CitadelDaoBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[CitadelDaoClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return CitadelDaoClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> CitadelDaoClient:
        """Get an app client by creator address and name"""
        return CitadelDaoClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> CitadelDaoClient:
        """Get an app client by app ID"""
        return CitadelDaoClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class CitadelDaoFactoryParams:
    """Parameters for creating transactions for CitadelDao contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CitadelDaoFactoryCreateParams(app_factory)
        self.update = CitadelDaoFactoryUpdateParams(app_factory)
        self.delete = CitadelDaoFactoryDeleteParams(app_factory)

class CitadelDaoFactoryCreateParams:
    """Parameters for 'create' operations of CitadelDao contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def create_dao_proposal(
        self,
        args: tuple[str, str, str, int, int, int, int, algokit_utils.AppMethodCallTransactionArgument] | CreateDaoProposalArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_dao_proposal(string,string,string,uint64,uint64,uint64,uint64,pay)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_dao_proposal(string,string,string,uint64,uint64,uint64,uint64,pay)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def join_dao(
        self,
        args: tuple[str, algokit_utils.AppMethodCallTransactionArgument] | JoinDaoArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the join_dao(string,pay)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "join_dao(string,pay)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def create_proposal(
        self,
        args: tuple[str, str, str, str] | CreateProposalArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_proposal(string,string,string,string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_proposal(string,string,string,string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def vote_on_proposal(
        self,
        args: tuple[str, bool] | VoteOnProposalArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the vote_on_proposal(string,bool)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "vote_on_proposal(string,bool)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def execute_proposal(
        self,
        args: tuple[str, str] | ExecuteProposalArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the execute_proposal(string,string)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "execute_proposal(string,string)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def distribute_revenue(
        self,
        args: tuple[str, int] | DistributeRevenueArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the distribute_revenue(string,uint64)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "distribute_revenue(string,uint64)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_dao_info(
        self,
        args: tuple[str] | GetDaoInfoArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_dao_info(string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_dao_info(string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_proposal_info(
        self,
        args: tuple[str] | GetProposalInfoArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_proposal_info(string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_proposal_info(string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def check_membership(
        self,
        args: tuple[str, str | bytes] | CheckMembershipArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the check_membership(string,account)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "check_membership(string,account)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_treasury_balance(
        self,
        args: tuple[str] | GetTreasuryBalanceArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_treasury_balance(string)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_treasury_balance(string)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

class CitadelDaoFactoryUpdateParams:
    """Parameters for 'update' operations of CitadelDao contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class CitadelDaoFactoryDeleteParams:
    """Parameters for 'delete' operations of CitadelDao contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class CitadelDaoFactoryCreateTransaction:
    """Create transactions for CitadelDao contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CitadelDaoFactoryCreateTransactionCreate(app_factory)


class CitadelDaoFactoryCreateTransactionCreate:
    """Create new instances of CitadelDao contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class CitadelDaoFactorySend:
    """Send calls to CitadelDao contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CitadelDaoFactorySendCreate(app_factory)


class CitadelDaoFactorySendCreate:
    """Send create calls to CitadelDao contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[CitadelDaoClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return CitadelDaoClient(result[0]), result[1]


class CitadelDaoComposer:
    """Composer for creating transaction groups for CitadelDao contract calls"""

    def __init__(self, client: "CitadelDaoClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def create_dao_proposal(
        self,
        args: tuple[str, str, str, int, int, int, int, algokit_utils.AppMethodCallTransactionArgument] | CreateDaoProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_dao_proposal(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_dao_proposal(string,string,string,uint64,uint64,uint64,uint64,pay)string", v
            )
        )
        return self

    def join_dao(
        self,
        args: tuple[str, algokit_utils.AppMethodCallTransactionArgument] | JoinDaoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.join_dao(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "join_dao(string,pay)string", v
            )
        )
        return self

    def create_proposal(
        self,
        args: tuple[str, str, str, str] | CreateProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_proposal(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_proposal(string,string,string,string)string", v
            )
        )
        return self

    def vote_on_proposal(
        self,
        args: tuple[str, bool] | VoteOnProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.vote_on_proposal(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "vote_on_proposal(string,bool)string", v
            )
        )
        return self

    def execute_proposal(
        self,
        args: tuple[str, str] | ExecuteProposalArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.execute_proposal(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "execute_proposal(string,string)uint64", v
            )
        )
        return self

    def distribute_revenue(
        self,
        args: tuple[str, int] | DistributeRevenueArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.distribute_revenue(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "distribute_revenue(string,uint64)string", v
            )
        )
        return self

    def get_dao_info(
        self,
        args: tuple[str] | GetDaoInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_dao_info(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_dao_info(string)string", v
            )
        )
        return self

    def get_proposal_info(
        self,
        args: tuple[str] | GetProposalInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_proposal_info(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_proposal_info(string)string", v
            )
        )
        return self

    def check_membership(
        self,
        args: tuple[str, str | bytes] | CheckMembershipArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.check_membership(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "check_membership(string,account)bool", v
            )
        )
        return self

    def get_treasury_balance(
        self,
        args: tuple[str] | GetTreasuryBalanceArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_treasury_balance(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_treasury_balance(string)uint64", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "CitadelDaoComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "CitadelDaoComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
